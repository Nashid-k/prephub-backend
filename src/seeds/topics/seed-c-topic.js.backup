import mongoose from 'mongoose';
import dotenv from 'dotenv';
import Topic from '../../models/Topic.js';
import Category from '../../models/Category.js';
import Section from '../../models/Section.js';
import path from 'path';
import { fileURLToPath } from 'url';
import { assignGroup } from '../utils/categoryGrouping.js';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

dotenv.config({ path: path.join(__dirname, '../../../.env') });

const cData = {
  "C_Programming_Fundamentals": {
    "01_introduction": {
      "core_concepts": [
        "C - Systems Programming Language",
        "History and Importance",
        "C vs C++ vs Other Languages",
        "Applications of C"
      ],
      "development_environment": [
        "Compiler Setup (GCC)",
        "IDE/Editor Setup",
        "Compilation Process (Preprocessor → Compiler → Linker)",
        "Hello World Program"
      ]
    },

    "02_basic_syntax": {
      "data_types": [
        "Basic Types (int, float, double, char)",
        "Type Modifiers (signed, unsigned, short, long)",
        "sizeof Operator",
        "Type Qualifiers (const, volatile)"
      ],
      "variables_constants": [
        "Variable Declaration and Initialization",
        "Naming Conventions",
        "Constants (#define, const)",
        "Scope and Lifetime"
      ]
    }
  },

  "Operators_Expressions": {
    "operators": [
      "Arithmetic Operators (+, -, *, /, %, ++, --)",
      "Relational Operators (==, !=, >, <, >=, <=)",
      "Logical Operators (&&, ||, !)",
      "Bitwise Operators (&, |, ^, ~, <<, >>)",
      "Assignment Operators (=, +=, -=, etc.)",
      "Ternary Operator (?:)"
    ],

    "expressions": [
      "Operator Precedence and Associativity",
      "Type Conversion (Implicit and Explicit)",
      "Expression Evaluation"
    ]
  },

  "Input_Output": {
    "standard_io": [
      "printf() for Output",
      "scanf() for Input",
      "Format Specifiers (%d, %f, %c, %s)",
      "Escape Sequences (\\n, \\t, \\b)"
    ],

    "character_io": [
      "getchar() and putchar()",
      "gets() and puts() (with limitations)",
      "Safe Input Alternatives"
    ]
  },

  "Control_Flow": {
    "decision_making": [
      "if, if-else Statements",
      "Nested if-else",
      "switch-case Statement",
      "Conditional Expressions"
    ],

    "loops": [
      "while Loop",
      "do-while Loop",
      "for Loop",
      "Nested Loops",
      "break and continue Statements"
    ]
  },

  "Arrays": {
    "one_dimensional": [
      "Array Declaration and Initialization",
      "Array Access and Traversal",
      "Array Operations",
      "Array Limitations"
    ],

    "multi_dimensional": [
      "2D Arrays (Matrices)",
      "Declaration and Access",
      "Row-major Order",
      "Applications of 2D Arrays"
    ],

    "character_arrays": [
      "Strings as Character Arrays",
      "String Initialization",
      "Null Terminator (\\0)",
      "Basic String Operations"
    ]
  },

  "Pointers": {
    "01_pointer_basics": [
      "Pointer Declaration and Initialization",
      "Address-of Operator (&)",
      "Dereference Operator (*)",
      "NULL Pointer",
      "Pointer Arithmetic"
    ],

    "02_pointers_and_arrays": [
      "Array Name as Pointer",
      "Pointer to Array Elements",
      "Array of Pointers",
      "Pointer Indexing"
    ],

    "03_advanced_pointers": [
      "Pointer to Pointer",
      "Pointer to Function",
      "void Pointer (Generic Pointer)",
      "Pointer Best Practices"
    ]
  },

  "Functions": {
    "01_function_basics": [
      "Function Declaration (Prototype)",
      "Function Definition",
      "Function Call",
      "Return Values",
      "Parameters and Arguments"
    ],

    "02_parameter_passing": [
      "Pass by Value",
      "Pass by Reference (using Pointers)",
      "Arrays as Parameters",
      "Returning Values from Functions"
    ],

    "03_function_types": [
      "Standard Library Functions",
      "User-defined Functions",
      "Recursive Functions",
      "Static Functions",
      "Inline Functions"
    ],

    "04_scope_storage": [
      "Local vs Global Variables",
      "Block Scope",
      "Storage Classes (auto, register, static, extern)",
      "Variable Lifetime"
    ]
  },

  "Strings": {
    "string_operations": [
      "String Length (strlen)",
      "String Copy (strcpy, strncpy)",
      "String Concatenation (strcat, strncat)",
      "String Comparison (strcmp, strncmp)"
    ],

    "character_functions": [
      "Character Classification (isalpha, isdigit)",
      "Character Conversion (toupper, tolower)",
      "String Searching (strchr, strstr)"
    ],

    "memory_functions": [
      "memcpy for Memory Copy",
      "memset for Memory Set",
      "memcmp for Memory Compare",
      "memmove for Overlapping Memory"
    ]
  },

  "Structures_Unions": {
    "structures": [
      "Structure Definition",
      "Structure Variable Declaration",
      "Accessing Members (., ->)",
      "Structure Initialization",
      "Array of Structures",
      "Nested Structures"
    ],

    "unions": [
      "Union Definition",
      "Union vs Structure",
      "Union Memory Usage",
      "Practical Applications"
    ],

    "type_definitions": [
      "typedef for Type Aliases",
      "typedef with Structures",
      "enum for Enumerations"
    ]
  },

  "Dynamic_Memory_Allocation": {
    "memory_functions": [
      "malloc for Memory Allocation",
      "calloc for Contiguous Allocation",
      "realloc for Reallocation",
      "free for Memory Deallocation"
    ],

    "memory_management": [
      "Heap Memory Usage",
      "Memory Leak Prevention",
      "Common Memory Errors",
      "Dynamic Arrays"
    ]
  },

  "File_Handling": {
    "01_file_basics": [
      "File Operations (Open, Read, Write, Close)",
      "File Modes (r, w, a, r+, w+, a+)",
      "Text vs Binary Files",
      "FILE Pointer"
    ],

    "02_file_operations": [
      "Character I/O (fgetc, fputc)",
      "String I/O (fgets, fputs)",
      "Formatted I/O (fprintf, fscanf)",
      "Binary I/O (fread, fwrite)"
    ],

    "03_file_management": [
      "File Positioning (fseek, ftell, rewind)",
      "Error Handling (feof, ferror)",
      "File Copy Operations",
      "File Processing Patterns"
    ]
  },

  "Preprocessor_Directives": {
    "directives": [
      "#include for File Inclusion",
      "#define for Macros",
      "#ifdef, #ifndef for Conditional Compilation",
      "#if, #elif, #else",
      "Predefined Macros (__DATE__, __LINE__)"
    ]
  },

  "Memory_Layout": {
    "segments": [
      "Text Segment (Code)",
      "Data Segment (Initialized Data)",
      "BSS Segment (Uninitialized Data)",
      "Stack Memory",
      "Heap Memory",
      "Function Call Stack"
    ]
  },

  "Command_Line_Arguments": {
    "basics": [
      "argc and argv Parameters",
      "Processing Command Line Input",
      "Argument Parsing",
      "Practical Applications"
    ]
  },

  "Standard_Library": {
    "essential_headers": {
      "stdio.h": ["Input/Output Functions"],
      "stdlib.h": ["Memory Allocation, Type Conversion"],
      "string.h": ["String Manipulation"],
      "math.h": ["Mathematical Functions"],
      "ctype.h": ["Character Handling"],
      "time.h": ["Date and Time Functions"]
    }
  },

  "Data_Structures": {
    "01_linked_lists": [
      "Singly Linked List Implementation",
      "Node Structure",
      "Insert, Delete, Traverse Operations",
      "Linked List Applications"
    ],

    "02_stacks_queues": [
      "Stack Implementation (Array/Linked List)",
      "Stack Operations (Push, Pop, Peek)",
      "Queue Implementation",
      "Queue Operations (Enqueue, Dequeue)"
    ],

    "03_trees": [
      "Binary Tree Basics",
      "Binary Search Tree Implementation",
      "Tree Traversals (Inorder, Preorder, Postorder)"
    ],

    "04_sorting_searching": [
      "Bubble Sort, Selection Sort, Insertion Sort",
      "Merge Sort, Quick Sort Basics",
      "Linear Search and Binary Search",
      "Algorithm Complexity Basics"
    ]
  },

  "Recursion": {
    "concepts": [
      "Recursive Function Design",
      "Base Case and Recursive Case",
      "Recursion vs Iteration",
      "Stack Usage in Recursion",
      "Common Recursive Problems"
    ]
  },

  "Bit_Manipulation": {
    "basics": [
      "Bitwise Operations",
      "Bit Masking",
      "Bit Fields in Structures",
      "Practical Applications"
    ]
  },

  "Error_Handling": {
    "techniques": [
      "Return Value Checking",
      "Error Codes",
      "errno Variable",
      "perror() Function",
      "Robust Programming Practices"
    ]
  },

  "Debugging_Tools": {
    "tools": [
      "Print Statement Debugging",
      "GDB Basics (GNU Debugger)",
      "Common Compiler Warnings",
      "Code Analysis Tools"
    ]
  },

  "Best_Practices": {
    "01_code_quality": [
      "Meaningful Variable Names",
      "Consistent Code Formatting",
      "Commenting Guidelines",
      "Function Size and Complexity"
    ],

    "02_performance": [
      "Efficient Loop Structures",
      "Memory Usage Optimization",
      "Algorithm Selection",
      "Compiler Optimization Flags"
    ],

    "03_security": [
      "Buffer Overflow Prevention",
      "Input Validation",
      "Safe String Functions",
      "Memory Safety"
    ]
  },

  "Essential_Projects": {
    "beginner_projects": [
      "Calculator with Menu",
      "Student Grade Management System",
      "Bank Account Simulation",
      "Number Guessing Game"
    ],

    "intermediate_projects": [
      "File Encryption/Decryption Tool",
      "Contact Management System",
      "Mini Database with File Storage",
      "Text File Statistics Generator"
    ],

    "must_implement_features": [
      "Dynamic Array Implementation",
      "Linked List Operations",
      "File I/O Operations",
      "Command Line Interface",
      "Data Sorting and Searching"
    ]
  },

  "Interview_Preparation": {
    "core_concepts": [
      "Pointers and Memory Management",
      "Arrays and Strings",
      "Functions and Recursion",
      "Structures and Unions",
      "File Handling",
      "Dynamic Memory Allocation"
    ],

    "practical_skills": [
      "Implement Data Structures",
      "File Processing Programs",
      "Memory Management Exercises",
      "Algorithm Implementation",
      "Debugging C Code"
    ],

    "common_problems": [
      "String Manipulation Problems",
      "Array Processing Problems",
      "Pointer-based Problems",
      "File I/O Problems",
      "Recursive Problems"
    ]
  }
};

const formatName = (str) => {
    return str
        .replace(/^\\d+_/, '')
        .split('_')
        .map(word => word.charAt(0).toUpperCase() + word.slice(1))
        .join(' ');
};

const seedC = async () => {
    try {
        await mongoose.connect(process.env.MONGODB_URI);
        console.log('Connected to MongoDB');

        let topic = await Topic.findOne({ slug: 'c' });
        if (!topic) {
            console.log('Creating C topic...');
            topic = await Topic.create({
                name: 'C',
                slug: 'c',
                description: 'Master systems programming with C language',
                icon: '©️',
                order: 11,
                color: '#A8B9CC'
            });
        }

        const categoriesToDelete = await Category.find({ topicId: topic._id });
        const categoryIds = categoriesToDelete.map(c => c._id);
        if (categoryIds.length > 0) {
            await Section.deleteMany({ topicId: topic._id });
            await Category.deleteMany({ topicId: topic._id });
            console.log('Cleared existing C data');
        }

        const seenSlugs = new Set();
        const generateUniqueSlug = (title) => {
            let baseSlug = title.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/(^-|-$)/g, '');
            let slug = baseSlug;
            let counter = 1;
            while (seenSlugs.has(slug)) {
                counter++;
                slug = `${baseSlug}-${counter}`;
            }
            seenSlugs.add(slug);
            return slug;
        };

        let order = 1;
        for (const [mainKey, mainValue] of Object.entries(cData)) {
            const groupName = formatName(mainKey); // Use mainKey as group - maintains study order!
            
            for (const [key, value] of Object.entries(mainValue)) {
                const categoryName = formatName(key);
                const categorySlug = generateUniqueSlug(categoryName);

                const category = await Category.create({
                    name: categoryName,
                    slug: categorySlug,
                    description: `Learn about ${categoryName}`,
                    topicId: topic._id,
                    group: groupName, // Direct from seed structure!
                    order: order++
                });

                let sections = [];
                if (Array.isArray(value)) {
                    sections = value;
                } else {
                    for (const [subKey, subItems] of Object.entries(value)) {
                        sections = [...sections, ...subItems];
                    }
                }

                const sectionDocs = sections.map((sectionTitle, index) => ({
                    title: sectionTitle,
                    slug: generateUniqueSlug(sectionTitle),
                    description: `Detailed explanation of ${sectionTitle}`,
                    content: 'Coming soon...',
                    categoryId: category._id,
                    topicId: topic._id,
                    order: index + 1,
                    difficulty: categoryName.includes('Advanced') || categoryName.includes('Data Structures') || categoryName.includes('Bit Manipulation') ? 'advanced' : 
                               categoryName.includes('Introduction') || categoryName.includes('Fundamentals') || categoryName.includes('Basic') ? 'beginner' : 'intermediate',
                    estimatedTime: 15
                }));

                await Section.insertMany(sectionDocs);
                console.log(`Created Category: ${categoryName} (Group: ${formatName(mainKey)}) with ${sectionDocs.length} sections`);
            }
        }

        console.log('✅ C seeding complete!');
        process.exit(0);
    } catch (error) {
        console.error('Error seeding data:', error);
        process.exit(1);
    }
};

seedC();
